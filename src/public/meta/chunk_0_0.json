[
  {
    "x": 4,
    "y": 2,
    "w": 1,
    "h": 2,
    "url": "./workers/worker1.js",
    "events": {
      "pointerdown": true
    },
    "preload": true,
    "src": "let wCells, hCells, width, height, ctx;\n\nself.onmessage = (e) => {\n  if (e.data.type === 'init') {\n    wCells = e.data.wCells;\n    hCells = e.data.hCells;\n    width = e.data.width;\n    height = e.data.height;\n    ctx = e.data.offCanvas.getContext('2d');\n    draw();\n  } else {\n    handle(e);\n  }\n};\n\nlet color = 'cyan';\n\nfunction draw() {\n  ctx.clearRect(0, 0, width, height);\n  ctx.fillStyle = '#3aa';\n  ctx.fillRect(0, 0, width, height);\n  ctx.fillStyle = color;\n  ctx.beginPath();\n  ctx.arc(width / 2, height / 2, Math.min(height, width) / 3, 0, 2 * Math.PI);\n  ctx.fill();\n}\n\nfunction changeColor() {\n  color = 'hsl(' + Math.random() * 360 + ',100%,50%)';\n  draw();\n}\n\nfunction handle(e) {\n  if (\n    e.data.type === 'message' &&\n    e.data.payload &&\n    e.data.payload.command === 'ChangeColor'\n  ) {\n    changeColor();\n  }\n\n  if (e.data.type === 'pointerdown') {\n    const { x, y, pointerId, eventId } = e.data.payload;\n\n    const r = Math.min(height, width) / 3,\n      dx = x - width / 2,\n      dy = y - height / 2;\n    if (dx * dx + dy * dy <= r * r) {\n      changeColor();\n    } else {\n      postMessage({ type: 're-emit', payload: { eventId } });\n    }\n  }\n}\n"
  },
  {
    "x": 3,
    "y": 3,
    "w": 1,
    "h": 1,
    "url": "./workers/worker2.js",
    "events": {
      "pointerdown": true
    },
    "preload": true,
    "src": "let wCells, hCells, width, height, ctx;\n\nself.onmessage = (e) => {\n  if (e.data.type === 'init') {\n    wCells = e.data.wCells;\n    hCells = e.data.hCells;\n    width = e.data.width;\n    height = e.data.height;\n    ctx = e.data.offCanvas.getContext('2d');\n    draw();\n  } else {\n    handle(e);\n  }\n};\n\nconst dirs = [['n', [1, 0]], ['n', 's'], 'n'];\nlet di = 0;\n\nfunction draw() {\n  ctx.clearRect(0, 0, width, height);\n  ctx.fillStyle = '#a31';\n  ctx.fillRect(0, 0, width, height);\n  ctx.fillStyle = '#fff';\n  ctx.font = 'bold 14px sans-serif';\n  ctx.fillText('Click Me', 22, height / 2 + 6);\n}\n\nfunction handle(e) {\n  if (e.data.type === 'pointerdown') {\n    const to = dirs[di];\n    di = (di + 1) % dirs.length;\n    postMessage({\n      type: 'message',\n      payload: { from: [0, 0], to, command: 'ChangeColor' },\n    });\n  }\n}\n"
  },
  {
    "x": 2,
    "y": 4,
    "w": 2,
    "h": 1,
    "url": "./workers/worker1.js",
    "events": {
      "pointerdown": true
    },
    "preload": true,
    "src": "let wCells, hCells, width, height, ctx;\n\nself.onmessage = (e) => {\n  if (e.data.type === 'init') {\n    wCells = e.data.wCells;\n    hCells = e.data.hCells;\n    width = e.data.width;\n    height = e.data.height;\n    ctx = e.data.offCanvas.getContext('2d');\n    draw();\n  } else {\n    handle(e);\n  }\n};\n\nlet color = 'cyan';\n\nfunction draw() {\n  ctx.clearRect(0, 0, width, height);\n  ctx.fillStyle = '#3aa';\n  ctx.fillRect(0, 0, width, height);\n  ctx.fillStyle = color;\n  ctx.beginPath();\n  ctx.arc(width / 2, height / 2, Math.min(height, width) / 3, 0, 2 * Math.PI);\n  ctx.fill();\n}\n\nfunction changeColor() {\n  color = 'hsl(' + Math.random() * 360 + ',100%,50%)';\n  draw();\n}\n\nfunction handle(e) {\n  if (\n    e.data.type === 'message' &&\n    e.data.payload &&\n    e.data.payload.command === 'ChangeColor'\n  ) {\n    changeColor();\n  }\n\n  if (e.data.type === 'pointerdown') {\n    const { x, y, pointerId, eventId } = e.data.payload;\n\n    const r = Math.min(height, width) / 3,\n      dx = x - width / 2,\n      dy = y - height / 2;\n    if (dx * dx + dy * dy <= r * r) {\n      changeColor();\n    } else {\n      postMessage({ type: 're-emit', payload: { eventId } });\n    }\n  }\n}\n"
  },
  {
    "x": 2,
    "y": 3,
    "w": 1,
    "h": 1,
    "url": "./workers/worker3.js",
    "events": {},
    "preload": true,
    "src": "let wCells, hCells, width, height, ctx;\n\nself.onmessage = (e) => {\n  if (e.data.type === 'init') {\n    wCells = e.data.wCells;\n    hCells = e.data.hCells;\n    width = e.data.width;\n    height = e.data.height;\n    ctx = e.data.offCanvas.getContext('2d');\n    draw();\n  }\n};\n\nlet angle = 0;\n\nfunction draw() {\n  ctx.fillStyle = 'black';\n  ctx.fillRect(0, 0, width, height);\n\n  // Tesseract: 16 vertices in 4D\n  const size = Math.min(width, height) * 0.2;\n  const vertices4D = [];\n  for (let i = 0; i < 16; i++) {\n    vertices4D.push([\n      i & 1 ? size : -size,\n      i & 2 ? size : -size,\n      i & 4 ? size : -size,\n      i & 8 ? size : -size,\n    ]);\n  }\n\n  // Rotation in 4D (XY and WZ planes)\n  const rotate4D = (v, a) => {\n    // XY\n    let [x, y, z, w] = v;\n    let x1 = x * Math.cos(a) - y * Math.sin(a);\n    let y1 = x * Math.sin(a) + y * Math.cos(a);\n    // WZ\n    let z1 = z * Math.cos(a) - w * Math.sin(a);\n    let w1 = z * Math.sin(a) + w * Math.cos(a);\n    return [x1, y1, z1, w1];\n  };\n\n  // Projection 4D -> 3D\n  const project4Dto3D = ([x, y, z, w]) => {\n    const wDist = 6 * size; // Was 3 * size, now 6 * size\n    const factor = wDist / (wDist - w);\n    return [x * factor, y * factor, z * factor];\n  };\n\n  // Projection 3D -> 2D\n  const project3Dto2D = ([x, y, z]) => {\n    const zDist = 8 * size; // Was 4 * size, now 8 * size\n    const factor = zDist / (zDist - z);\n    return [width / 2 + x * factor, height / 2 + y * factor];\n  };\n\n  // Rotation in 3D (XZ and YZ)\n  const rotate3D = (v, a) => {\n    let [x, y, z] = v;\n    // XZ\n    let x1 = x * Math.cos(a * 0.7) - z * Math.sin(a * 0.7);\n    let z1 = x * Math.sin(a * 0.7) + z * Math.cos(a * 0.7);\n    // YZ\n    let y1 = y * Math.cos(a * 0.4) - z1 * Math.sin(a * 0.4);\n    let z2 = y * Math.sin(a * 0.4) + z1 * Math.cos(a * 0.4);\n    return [x1, y1, z2];\n  };\n\n  // Transform all vertices\n  const projected = vertices4D.map((v) =>\n    project3Dto2D(rotate3D(project4Dto3D(rotate4D(v, angle)), angle)),\n  );\n\n  // Tesseract edges: connect vertices differing by 1 bit\n  ctx.strokeStyle = 'white';\n  ctx.lineWidth = 1.5;\n  for (let i = 0; i < 16; i++) {\n    for (let j = i + 1; j < 16; j++) {\n      if (((i ^ j) & ((i ^ j) - 1)) === 0) {\n        // difference in exactly one bit\n        ctx.beginPath();\n        ctx.moveTo(projected[i][0], projected[i][1]);\n        ctx.lineTo(projected[j][0], projected[j][1]);\n        ctx.stroke();\n      }\n    }\n  }\n\n  angle += 0.015;\n  requestAnimationFrame(draw);\n}\n"
  },
  {
    "x": 3,
    "y": 2,
    "w": 1,
    "h": 1,
    "url": "./workers/worker4.js",
    "events": {},
    "preload": true,
    "src": "let wCells, hCells, width, height, ctx;\nlet flashState = 'idle'; // 'idle', 'flashing', 'fading'\nlet flashAlpha = 0;\nlet flashStart, fadeStart;\nconst FLASH_DURATION = 80; // ms, fast white flash\nconst FADE_DURATION = 180; // ms, slower fade to black\n\nself.onmessage = (e) => {\n  if (e.data.type === 'init') {\n    wCells = e.data.wCells;\n    hCells = e.data.hCells;\n    width = e.data.width;\n    height = e.data.height;\n    ctx = e.data.offCanvas.getContext('2d');\n    draw();\n  }\n  if (e.data.type === 'message') {\n    startFlash();\n  }\n};\n\nfunction startFlash() {\n  flashState = 'flashing';\n  flashAlpha = 1;\n  flashStart = performance.now();\n  requestAnimationFrame(animateFlash);\n}\n\nfunction animateFlash(now) {\n  if (flashState === 'flashing') {\n    const elapsed = now - flashStart;\n    if (elapsed < FLASH_DURATION) {\n      flashAlpha = 1;\n      draw();\n      requestAnimationFrame(animateFlash);\n    } else {\n      flashState = 'fading';\n      fadeStart = now;\n      requestAnimationFrame(animateFlash);\n    }\n  } else if (flashState === 'fading') {\n    const elapsed = now - fadeStart;\n    flashAlpha = 1 - Math.min(elapsed / FADE_DURATION, 1);\n    draw();\n    if (elapsed < FADE_DURATION) {\n      requestAnimationFrame(animateFlash);\n    } else {\n      flashState = 'idle';\n      flashAlpha = 0;\n      draw();\n    }\n  }\n}\n\nfunction draw() {\n  ctx.fillStyle = 'black';\n  ctx.fillRect(0, 0, width, height);\n\n  if (flashAlpha > 0) {\n    ctx.globalAlpha = flashAlpha;\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, width, height);\n    ctx.globalAlpha = 1.0;\n  }\n}\n"
  },
  {
    "x": 2,
    "y": 2,
    "w": 1,
    "h": 1,
    "url": "./workers/worker5.js",
    "events": {
      "pointerdown": true
    },
    "preload": true,
    "src": "let wCells, hCells, width, height, ctx;\nlet gameState = 'start'; // start | running | gameover\nlet dino,\n  obstacles,\n  score,\n  groundY,\n  velocityY,\n  gravity,\n  jumpPower,\n  speed,\n  buttonRect,\n  lastFrame;\nlet bestScore = 0;\n\nself.onmessage = (e) => {\n  if (e.data.type === 'init') {\n    wCells = e.data.wCells;\n    hCells = e.data.hCells;\n    width = e.data.width;\n    height = e.data.height;\n    ctx = e.data.offCanvas.getContext('2d');\n    setup();\n    draw();\n  }\n  if (e.data.type === 'pointerdown') {\n    handleClick(e);\n  }\n};\n\nfunction setup() {\n  groundY = height * 0.8;\n  dino = {\n    x: width * 0.1,\n    y: groundY - height * 0.1,\n    w: height * 0.07,\n    h: height * 0.1,\n    vy: 0,\n    jumping: false,\n  };\n  obstacles = [];\n  score = 0;\n  velocityY = 0;\n  gravity = height * 0.0025;\n  jumpPower = height * 0.045;\n  speed = width * 0.012;\n  buttonRect = {\n    x: width * 0.05,\n    y: groundY + height * 0.05,\n    w: width * 0.9,\n    h: height * 0.13,\n  };\n  lastFrame = performance.now();\n}\n\nfunction startGame() {\n  setup();\n  gameState = 'running';\n  requestAnimationFrame(gameLoop);\n}\n\nfunction gameOver() {\n  gameState = 'gameover';\n  if (score > bestScore) bestScore = score;\n  postMessage({ type: 'message', payload: { command: 'UpdateScore', score } });\n  draw();\n}\n\nfunction handleClick(e) {\n  const { x, y, eventId } = e.data.payload;\n\n  if (gameState === 'start') {\n    if (inRect(x, y, buttonRect)) {\n      startGame();\n    } else {\n      postMessage({\n        type: 're-emit',\n        payload: { eventId },\n      });\n    }\n  } else if (gameState === 'running') {\n    if (inRect(x, y, buttonRect)) {\n      jump();\n    } else {\n      postMessage({\n        type: 're-emit',\n        payload: { eventId },\n      });\n    }\n  } else if (gameState === 'gameover') {\n    if (inRect(x, y, buttonRect)) {\n      startGame();\n    } else {\n      postMessage({\n        type: 're-emit',\n        payload: { eventId },\n      });\n    }\n  }\n}\n\nfunction inRect(x, y, rect) {\n  return (\n    x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h\n  );\n}\n\nfunction jump() {\n  if (!dino.jumping) {\n    dino.vy = -jumpPower;\n    dino.jumping = true;\n  }\n}\n\nfunction gameLoop(now) {\n  if (gameState !== 'running') return;\n  let dt = (now - lastFrame) / 16.67; // normalize to 60fps\n  lastFrame = now;\n  update(dt);\n  draw();\n  requestAnimationFrame(gameLoop);\n}\n\nfunction update(dt) {\n  // Dino physics\n  dino.y += dino.vy * dt;\n  dino.vy += gravity * dt;\n  if (dino.y >= groundY - dino.h) {\n    dino.y = groundY - dino.h;\n    dino.vy = 0;\n    dino.jumping = false;\n  }\n\n  // Move obstacles\n  for (let obs of obstacles) {\n    obs.x -= speed * dt;\n  }\n  // Remove obstacles that are off-screen\n  obstacles = obstacles.filter((obs) => obs.x + obs.w > 0);\n\n  // Add new obstacles — always spawn outside the right edge\n  // Distance between obstacles decreases as score increases (progression)\n  let progression = Math.max(0.5, 1 - score / 1000); // from 1 to 0.5\n  let minGap = width * (0.18 * progression + 0.1); // from 0.28w to 0.19w\n  let maxGap = width * (0.32 * progression + 0.16); // from 0.48w to 0.32w\n\n  if (\n    obstacles.length === 0 ||\n    obstacles[obstacles.length - 1].x < width * 0.6\n  ) {\n    let h = height * (0.07 + Math.random() * 0.07);\n    let w = h * (0.3 + Math.random() * 0.2);\n    let gap = minGap + Math.random() * (maxGap - minGap);\n    let x =\n      obstacles.length === 0\n        ? width + gap\n        : Math.max(\n            width + gap,\n            obstacles[obstacles.length - 1].x +\n              obstacles[obstacles.length - 1].w +\n              gap,\n          );\n    obstacles.push({\n      x,\n      y: groundY - h,\n      w,\n      h,\n    });\n  }\n\n  // Collision detection\n  for (let obs of obstacles) {\n    if (\n      dino.x < obs.x + obs.w &&\n      dino.x + dino.w > obs.x &&\n      dino.y < obs.y + obs.h &&\n      dino.y + dino.h > obs.y\n    ) {\n      gameOver();\n      return;\n    }\n  }\n\n  // Score and progression (speed up)\n  score += Math.floor(dt);\n  speed = width * (0.012 + 0.008 * Math.min(1, score / 1000)); // from 0.012 to 0.02\n}\n\nfunction draw() {\n  ctx.clearRect(0, 0, width, height);\n\n  // Background\n  ctx.fillStyle = '#fff';\n  ctx.fillRect(0, 0, width, height);\n\n  // Ground\n  ctx.strokeStyle = '#222';\n  ctx.lineWidth = 3;\n  ctx.beginPath();\n  ctx.moveTo(0, groundY);\n  ctx.lineTo(width, groundY);\n  ctx.stroke();\n\n  // Obstacles\n  ctx.strokeStyle = '#111';\n  ctx.lineWidth = 2;\n  for (let obs of obstacles) {\n    ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);\n  }\n\n  // Dino\n  ctx.strokeStyle = '#111';\n  ctx.lineWidth = 2;\n  ctx.strokeRect(dino.x, dino.y, dino.w, dino.h);\n\n  // Score\n  if (gameState !== 'gameover') {\n    ctx.fillStyle = '#111';\n    ctx.font = `${Math.floor(height * 0.35)}px monospace`;\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'top';\n    ctx.fillText(`${score}`, 0, 0);\n  }\n\n  // Button\n  ctx.fillStyle = '#eee';\n  ctx.strokeStyle = '#111';\n  ctx.lineWidth = 2;\n  ctx.fillRect(buttonRect.x, buttonRect.y, buttonRect.w, buttonRect.h);\n  ctx.strokeRect(buttonRect.x, buttonRect.y, buttonRect.w, buttonRect.h);\n  ctx.fillStyle = '#111';\n  ctx.font = `${Math.floor(height * 0.1)}px monospace`;\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'middle';\n  let btnText = '';\n  if (gameState === 'start') btnText = 'START';\n  else if (gameState === 'running') btnText = 'JUMP';\n  else if (gameState === 'gameover') btnText = 'RESTART';\n  ctx.fillText(\n    btnText,\n    buttonRect.x + buttonRect.w / 2,\n    buttonRect.y + buttonRect.h / 2,\n  );\n\n  // Game over text\n  if (gameState === 'gameover') {\n    ctx.fillStyle = '#111';\n    ctx.font = `${Math.floor(height * 0.18)}px monospace`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText('GAME OVER', width / 2, height * 0.3);\n    ctx.font = `${Math.floor(height * 0.18)}px monospace`;\n    ctx.fillText(`Score: ${bestScore}`, width / 2, height * 0.5);\n  }\n}\n"
  },
  {
    "x": 2,
    "y": 1,
    "w": 1,
    "h": 1,
    "url": "./workers/worker6.js",
    "events": {},
    "preload": true,
    "src": "let wCells, hCells, width, height, ctx;\nlet score = 0;\n\nself.onmessage = (e) => {\n  if (e.data.type === 'init') {\n    wCells = e.data.wCells;\n    hCells = e.data.hCells;\n    width = e.data.width;\n    height = e.data.height;\n    ctx = e.data.offCanvas.getContext('2d');\n    draw();\n  } else {\n    handle(e);\n  }\n};\n\nfunction draw() {\n  ctx.clearRect(0, 0, width, height);\n  ctx.fillStyle = '#fff';\n  ctx.fillRect(0, 0, width, height);\n\n  ctx.fillStyle = '#000';\n  ctx.font = `${Math.floor(height * 0.5)}px sans-serif`;\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'middle';\n  ctx.fillText(String(score), width / 2, height / 2);\n}\n\nfunction handle(e) {\n  if (\n    e.data.type === 'message' &&\n    e.data.payload &&\n    e.data.payload.command === 'UpdateScore'\n  ) {\n    score = e.data.payload.score;\n    draw();\n  }\n}\n"
  }
]