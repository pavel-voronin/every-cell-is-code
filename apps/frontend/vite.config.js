import { defineConfig } from 'vite';
import { preloadChunks } from './package.json';
import fs from 'fs';
import { CHUNK_SIZE } from './src/app/constants';
import path from 'path';

export default defineConfig({
  root: 'src',
  build: {
    outDir: '../dist',
    emptyOutDir: true,
  },
  appType: 'mpa',
  server: {
    allowedHosts: true,
  },
  plugins: [
    {
      name: 'generate-known-chunks',
      buildStart() {
        const metaDir = './src/public/meta';
        const outFile = './src/app/knownChunks.ts';
        const chunkRe = /^chunk_(-?\d+)_(-?\d+)\.json$/;
        const coords = [];
        for (const file of fs.readdirSync(metaDir)) {
          const match = file.match(chunkRe);
          if (match) {
            coords.push([parseInt(match[1], 10), parseInt(match[2], 10)]);
          }
        }
        const content = `// Auto-generated by vite plugin\nimport { TupleSet } from './structures/tuppleSet';\n// prettier-ignore\nexport default new TupleSet(${JSON.stringify(coords)}) as TupleSet;\n`;
        fs.writeFileSync(outFile, content);
      },
    },
    {
      name: 'process-blocks-with-templated-workers',
      async buildStart() {
        const blocksDir = './src/public/blocks';
        const blockRe = /^block_(-?\d+)_(-?\d+)\.json$/;
        for (const file of fs.readdirSync(blocksDir)) {
          const match = file.match(blockRe);
          if (!match) continue;
          const blockPath = `${blocksDir}/${file}`;
          let block = JSON.parse(fs.readFileSync(blockPath, 'utf-8'));

          if (
            block.backend.type !== 'worker' ||
            block.backend.resource === undefined ||
            block.backend.resource.type !== 'worker' ||
            block.backend.resource.file === undefined ||
            block.backend.resource.template === undefined ||
            block.backend.resource.url === undefined
          )
            continue;

          const worker_dist_file = block.backend.resource.url.replace(
            /^\.\/blocks\//,
            './',
          );

          const templateFile = `${blocksDir}/templates/${block.backend.resource.template}.js`;
          const workerFile = `${blocksDir}/${block.backend.resource.file}`;
          const distPath = `${blocksDir}/${worker_dist_file}`;

          if (fs.existsSync(templateFile) && fs.existsSync(workerFile)) {
            const template = fs.readFileSync(templateFile, 'utf-8');
            const worker = fs.readFileSync(workerFile, 'utf-8');
            fs.writeFileSync(distPath, `${template}\n${worker}`);
          }

          if (block.backend.resource.file) {
            const workerFile = `${blocksDir}/${block.backend.resource.file}`;
            const worker = fs.readFileSync(workerFile, 'utf-8');
            const eventMap = {
              onPointerDown: 'pointerdown',
              onPointerUp: 'pointerup',
              onPointerMove: 'pointermove',
              onKeyDown: 'keydown',
              onKeyUp: 'keyup',
              onWheel: 'wheel',
            };

            const events = Object.keys(eventMap)
              .filter((event) => worker.includes(`function ${event}`))
              .reduce((acc, event) => {
                acc[eventMap[event]] = true;
                return acc;
              }, {});

            block.input.events = events;

            fs.writeFileSync(blockPath, JSON.stringify(block, null, 2) + '\n');
          }
        }
      },
    },
    {
      name: 'make-chunks',
      async buildStart() {
        const metaDir = './src/public/meta';
        const blocksDir = './src/public/blocks';
        const chunkRe = /^chunk_(-?\d+)_(-?\d+)\.json$/;
        const blockRe = /^block_(-?\d+)_(-?\d+)\.json$/;

        // 1. Remove old chunk files
        for (const file of fs.readdirSync(metaDir)) {
          if (chunkRe.test(file)) {
            fs.unlinkSync(path.join(metaDir, file));
          }
        }

        // 2. Collect and convert blocks
        const chunks = new Map();
        for (const file of fs.readdirSync(blocksDir)) {
          const match = file.match(blockRe);
          if (!match) continue;
          const blockPath = path.join(blocksDir, file);
          const block = JSON.parse(fs.readFileSync(blockPath, 'utf-8'));

          const chunkX = Math.floor(block.x / CHUNK_SIZE);
          const chunkY = Math.floor(block.y / CHUNK_SIZE);
          const chunkKey = `${chunkX}_${chunkY}`;

          if (!chunks.has(chunkKey)) chunks.set(chunkKey, []);

          chunks.get(chunkKey).push(block);
        }

        // 3. Write new chunk files
        for (const [chunkKey, blocks] of chunks.entries()) {
          const chunkPath = path.join(metaDir, `chunk_${chunkKey}.json`);
          fs.writeFileSync(chunkPath, JSON.stringify(blocks, null, 2));
        }
      },
    },
    {
      name: 'inject-preload-chunks',
      enforce: 'post',
      async transform(code, id) {
        if (!id.endsWith('/app.ts')) return;

        if (!preloadChunks || !preloadChunks.length) return;

        const chunkCalls = preloadChunks
          .map((coords) => {
            const chunkPath = `./src/public/meta/chunk_${coords[0]}_${coords[1]}.json`;
            const blocks = JSON.parse(fs.readFileSync(chunkPath, 'utf-8'));
            return `this.metaManager.loadChunkData([${coords.join(',')}], ${JSON.stringify(blocks, null, 2)});`;
          })
          .filter(Boolean)
          .join('\n');

        return code.replace(`"__PRELOAD_CHUNKS__";`, chunkCalls);
      },
    },
    {
      name: 'watch-blocks',
      handleHotUpdate({ file, server }) {
        if (file.startsWith(server.config.root + '/public/blocks')) {
          server.restart();
        }
      },
    },
  ],
});
