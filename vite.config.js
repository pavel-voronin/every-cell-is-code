import { defineConfig } from 'vite';
import { version, preloadChunks } from './package.json';
import fs from 'fs';
import { CHUNK_SIZE } from './src/app/constants';
import path from 'path';

export default defineConfig({
  root: 'src',
  build: {
    outDir: '../dist',
    emptyOutDir: true,
  },
  appType: 'mpa',
  server: {
    allowedHosts: true,
  },
  plugins: [
    {
      name: 'inject-version',
      transformIndexHtml(html) {
        return html.replace(/%APP_VERSION%/g, version);
      },
    },
    {
      name: 'inject-preload-chunks',
      enforce: 'post',
      async transform(code, id) {
        if (!id.endsWith('/app.ts')) return;

        if (!preloadChunks || !preloadChunks.length) return;

        const chunkCalls = preloadChunks
          .map((coords) => {
            const chunkPath = `./src/public/meta/chunk_${coords[0]}_${coords[1]}.json`;
            const blocks = JSON.parse(fs.readFileSync(chunkPath, 'utf-8'));
            return `this.metaManager.loadChunkData([${coords.join(',')}], ${JSON.stringify(blocks, null, 2)});`;
          })
          .filter(Boolean)
          .join('\n');

        return code.replace(`"__PRELOAD_CHUNKS__";`, chunkCalls);
      },
    },
    {
      name: 'generate-known-chunks',
      buildStart() {
        const metaDir = './src/public/meta';
        const outFile = './src/app/knownChunks.ts';
        const chunkRe = /^chunk_(-?\d+)_(-?\d+)\.json$/;
        const coords = [];
        for (const file of fs.readdirSync(metaDir)) {
          const match = file.match(chunkRe);
          if (match) {
            coords.push([parseInt(match[1], 10), parseInt(match[2], 10)]);
          }
        }
        const content = `// Auto-generated by vite plugin\nimport { TupleSet } from './structures/tuppleSet';\nexport default new TupleSet(${JSON.stringify(coords)}) as TupleSet;\n`;
        fs.writeFileSync(outFile, content);
      },
    },
    {
      name: 'process-blocks-with-templated-workers',
      async buildStart() {
        const blocksDir = './src/public/blocks';
        const blockRe = /^block_(-?\d+)_(-?\d+)\.json$/;
        for (const file of fs.readdirSync(blocksDir)) {
          const match = file.match(blockRe);
          if (!match) continue;
          const blockPath = `${blocksDir}/${file}`;
          let block = JSON.parse(fs.readFileSync(blockPath, 'utf-8'));

          if (block.type !== 'templated_worker') continue;

          if (block.worker_dist_file === undefined) {
            block.worker_dist_file = `./block_${match[1]}_${match[2]}.dist.js`;
          }

          if (block.template_file && block.worker_file) {
            const templateFile = `${blocksDir}/${block.template_file}`;
            const workerFile = `${blocksDir}/${block.worker_file}`;
            const distPath = `${blocksDir}/${block.worker_dist_file}`;

            if (fs.existsSync(templateFile) && fs.existsSync(workerFile)) {
              const template = fs.readFileSync(templateFile, 'utf-8');
              const worker = fs.readFileSync(workerFile, 'utf-8');
              fs.writeFileSync(distPath, `${template}\n${worker}`);
            }
          }

          let events = {};
          if (block.worker_file) {
            const workerFile = `${blocksDir}/${block.worker_file}`;
            const worker = fs.readFileSync(workerFile, 'utf-8');
            const eventMap = {
              onPointerDown: 'pointerdown',
              onPointerUp: 'pointerup',
              onPointerMove: 'pointermove',
              onKeyDown: 'keydown',
              onKeyUp: 'keyup',
              onWheel: 'wheel',
            };

            Object.keys(eventMap)
              .filter((event) => worker.includes(`function ${event}`))
              .forEach((event) => {
                events[eventMap[event]] = true;
              });
          }

          // Write work file with only events and worker_dist_file
          const workFilePath = `${blocksDir}/${file.replace(/\.json$/, '.work.json')}`;
          fs.writeFileSync(
            workFilePath,
            JSON.stringify(
              {
                events,
                worker_dist_file: block.worker_dist_file,
              },
              null,
              2,
            ),
          );
        }
      },
    },
    {
      name: 'make-chunks',
      async buildStart() {
        const metaDir = './src/public/meta';
        const blocksDir = './src/public/blocks';
        const chunkRe = /^chunk_(-?\d+)_(-?\d+)\.json$/;
        const blockRe = /^block_(-?\d+)_(-?\d+)\.json$/;

        // 1. Remove old chunk files
        for (const file of fs.readdirSync(metaDir)) {
          if (chunkRe.test(file)) {
            fs.unlinkSync(path.join(metaDir, file));
          }
        }

        // 2. Collect and convert blocks
        const chunks = new Map();
        for (const file of fs.readdirSync(blocksDir)) {
          const match = file.match(blockRe);
          if (!match) continue;
          const blockPath = path.join(blocksDir, file);
          let block = JSON.parse(fs.readFileSync(blockPath, 'utf-8'));

          // Try to read work file for events and worker_dist_file
          const workFilePath = blockPath.replace(/\.json$/, '.work.json');
          let workData = null;
          if (fs.existsSync(workFilePath)) {
            workData = JSON.parse(fs.readFileSync(workFilePath, 'utf-8'));
          }

          // Extract coordinates and dimensions
          const x = block.x ?? parseInt(match[1], 10);
          const y = block.y ?? parseInt(match[2], 10);
          const w = block.w ?? 1;
          const h = block.h ?? 1;

          // Read source code from dist file (from work file if present)
          let src = '';
          let workerDistFile =
            workData?.worker_dist_file || block.worker_dist_file;
          if (workerDistFile) {
            const distPath = path.join(
              blocksDir,
              workerDistFile.replace(/^\.\//, ''),
            );
            if (fs.existsSync(distPath)) {
              src = fs.readFileSync(distPath, 'utf-8');
            }
          }

          let newBlock;
          // Compose new block structure
          if (block.type === 'templated_worker') {
            newBlock = {
              type: block.type,
              x,
              y,
              w,
              h,
              events: workData?.events || block.events || {},
              src,
            };
          } else if (block.type === 'image') {
            newBlock = {
              type: block.type,
              x,
              y,
              w,
              h,
              events: workData?.events || block.events || {},
              image_url: block.image_url,
            };
          }

          // Determine chunk coordinates
          const chunkX = Math.floor(x / CHUNK_SIZE);
          const chunkY = Math.floor(y / CHUNK_SIZE);
          const chunkKey = `${chunkX}_${chunkY}`;
          if (!chunks.has(chunkKey)) chunks.set(chunkKey, []);
          chunks.get(chunkKey).push(newBlock);
        }

        // 3. Write new chunk files
        for (const [chunkKey, blocks] of chunks.entries()) {
          const chunkPath = path.join(metaDir, `chunk_${chunkKey}.json`);
          fs.writeFileSync(chunkPath, JSON.stringify(blocks, null, 2));
        }
      },
    },
    {
      name: 'watch-blocks',
      handleHotUpdate({ file, server }) {
        if (file.startsWith(server.config.root + '/public/blocks')) {
          server.restart();
        }
      },
    },
  ],
});
